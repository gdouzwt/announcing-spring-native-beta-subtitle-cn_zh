1
00:00:07,450 --> 00:00:08,025
嗨

2
00:00:08,100 --> 00:00:09,175
我是Sébastien Deleuze

3
00:00:09,175 --> 00:00:11,848
我在VMware作为Spring框架贡献者

4
00:00:11,848 --> 00:00:14,700
然后今天我高兴地发布Spring Native Beta

5
00:00:14,975 --> 00:00:17,250
0.9.0 版本

6
00:00:17,800 --> 00:00:20,721
它提供了使用GraalVM原生镜像编译器

7
00:00:20,721 --> 00:00:24,100
编译Spring应用到原生可执行文件的支持

8
00:00:24,850 --> 00:00:28,850
原生镜像提供了一种有趣的替代部署选项

9
00:00:28,850 --> 00:00:31,375
与JVM相比有不同的特性

10
00:00:31,725 --> 00:00:33,375
例如快速启动

11
00:00:33,425 --> 00:00:34,825
瞬时峰值性能

12
00:00:34,825 --> 00:00:36,275
还有减少内存消耗

13
00:00:37,225 --> 00:00:39,800
不过目前这仍处于实验阶段

14
00:00:39,800 --> 00:00:43,625
Beta意味着我们现在对Spring的一些依赖子集提供了支持

15
00:00:44,100 --> 00:00:46,875
并且对于未来的变更会提供迁移路径

16
00:00:47,950 --> 00:00:49,300
另一个重大变更是

17
00:00:49,300 --> 00:00:52,425
Spring AOT Maven和Gradle插件的引入

18
00:00:52,825 --> 00:00:55,725
这允许执行前期编译转换

19
00:00:55,725 --> 00:00:58,700
以改善镜像的资源耗量和兼容性

20
00:00:59,250 --> 00:01:01,375
Andy和Brian稍后会分享更多相关内容

21
00:01:02,325 --> 00:01:04,637
但Spring Native Beta也意味着

22
00:01:04,637 --> 00:01:08,600
你现在可以直接在start.spring.io添加原生支持

23
00:01:08,800 --> 00:01:11,371
然后我想感谢Spring Boot团队的Stéphane Nicoll

24
00:01:11,371 --> 00:01:12,450
实现了这个功能

25
00:01:12,775 --> 00:01:13,625
让我们看一下演示

26
00:01:15,825 --> 00:01:17,950
OK 让我们尝试这个新的原生(native)支持

27
00:01:18,050 --> 00:01:20,275
那么只需去到start.spring.io

28
00:01:20,275 --> 00:01:22,550
或使用你喜欢的IDE里集成的

29
00:01:23,000 --> 00:01:25,068
并添加这个Spring Native依赖

30
00:01:25,068 --> 00:01:26,375
它现在已经可用了

31
00:01:26,950 --> 00:01:29,075
如果你生成了工程

32
00:01:29,125 --> 00:01:31,450
在这里的Maven工程你会看到

33
00:01:31,675 --> 00:01:34,025
start.spring.io自动定义了

34
00:01:34,025 --> 00:01:35,250
Spring Native版本

35
00:01:35,250 --> 00:01:37,275
添加了Spring Native依赖

36
00:01:38,300 --> 00:01:40,250
配置了Spring Boot Maven插件

37
00:01:40,250 --> 00:01:44,300
以便在容器镜像内生成一个原生镜像

38
00:01:44,900 --> 00:01:47,825
同时它也配置了Spring AOT Maven插件

39
00:01:48,425 --> 00:01:51,600
这个插件会执行提前编译转换(AOT)

40
00:01:51,600 --> 00:01:54,150
以便创建原生配置

41
00:01:54,450 --> 00:01:56,425
或者是会生成一些代码

42
00:01:56,525 --> 00:02:00,750
一些为你的应用及其类路径和配置生成的代码

43
00:02:02,475 --> 00:02:03,675
但这还有更多内容

44
00:02:03,675 --> 00:02:05,775
例如... 如果你添加...

45
00:02:05,775 --> 00:02:09,250
一个Spring Native未支持的依赖

46
00:02:09,925 --> 00:02:12,375
如果你生成了工程 你会看到

47
00:02:12,575 --> 00:02:14,250
在HELP.md文件里

48
00:02:14,775 --> 00:02:17,475
你会看到个性化的文档

49
00:02:17,500 --> 00:02:21,400
警告你那个依赖尚未支持

50
00:02:21,600 --> 00:02:23,500
那么我觉得这个挺有用

51
00:02:23,500 --> 00:02:25,250
所以请记得检测一下这个文件

52
00:02:25,625 --> 00:02:27,300
当你创建一个新工程时

53
00:02:28,100 --> 00:02:30,400
你也可以添加...

54
00:02:30,550 --> 00:02:31,375
JPA支持

55
00:02:31,375 --> 00:02:32,800
当你这样做...

56
00:02:33,425 --> 00:02:34,750
你会看到...

57
00:02:35,075 --> 00:02:38,550
start.spring.io为你执行了一些额外步骤

58
00:02:39,050 --> 00:02:42,825
它配置了Hibernate构建期字节码生成

59
00:02:43,025 --> 00:02:44,750
而不是运行时生成(字节码)

60
00:02:44,750 --> 00:02:46,650
通过这个hibernate-enhance-maven-plugin

61
00:02:46,650 --> 00:02:50,800
所以这里的目标还是让一些东西开箱即支持原生

62
00:02:52,775 --> 00:02:54,662
Gradle也同样支持

63
00:02:54,662 --> 00:02:56,125
所以只需选择Gradle

64
00:02:56,125 --> 00:02:58,675
你就有了这些Spring Native依赖

65
00:02:58,675 --> 00:03:03,425
你会看到Gradle版的AOT插件已配置好

66
00:03:04,000 --> 00:03:06,575
Spring Native依赖也配置好了

67
00:03:06,925 --> 00:03:09,050
同样的Spring Boot (Docker)镜像构建也配置好了

68
00:03:09,050 --> 00:03:11,100
是的 这应该可以开箱即用

69
00:03:11,100 --> 00:03:14,800
那么 尝试一下吧！ 给我们反馈

70
00:03:17,475 --> 00:03:20,025
嗨 我是 Andy Clement Spring团队的一位总监

71
00:03:20,875 --> 00:03:22,375
那么原生镜像的构建过程

72
00:03:22,375 --> 00:03:25,725
是尝试为你的应用构建尽可能优化的镜像

73
00:03:26,325 --> 00:03:30,325
这意味着镜像构建时 JDK中没用到的部分会被去掉

74
00:03:30,325 --> 00:03:33,900
部分没用到的依赖、库会丢弃

75
00:03:33,900 --> 00:03:35,924
甚至是你自己应用的部分

76
00:03:35,924 --> 00:03:37,600
如果知道不需要也会被丢弃

77
00:03:37,800 --> 00:03:40,500
resources如果不加载也不会被包含进来

78
00:03:40,500 --> 00:03:44,420
甚至是为满足反射调用的类元信息也不会被包含

79
00:03:44,420 --> 00:03:46,200
除非是非常有必要的

80
00:03:46,200 --> 00:03:47,404
为了达到此目的

81
00:03:47,404 --> 00:03:50,200
 GraalVM Native有非常精细的静态分析系统

82
00:03:50,600 --> 00:03:52,000
但它也有些限制

83
00:03:52,000 --> 00:03:56,300
某些Java机制 如反射 使得静态分析困难

84
00:03:56,300 --> 00:03:58,956
而它(GraalVM)不清楚框架及库

85
00:03:58,956 --> 00:04:01,800
是如何使用这些机制改善它们行为的

86
00:04:02,200 --> 00:04:03,100
为此

87
00:04:03,100 --> 00:04:06,200
你可以通过JSON文件配置原生镜像的构建过程

88
00:04:06,400 --> 00:04:09,100
这会导致在镜像中包含额外的内容

89
00:04:09,100 --> 00:04:11,600
即静态分析可能漏掉的东西

90
00:04:11,600 --> 00:04:13,900
这就是Spring Native的用处了

91
00:04:13,900 --> 00:04:17,600
它帮助原生镜像构建构成理解Spring应用

92
00:04:17,900 --> 00:04:20,900
Spring Native了解Spring Boot自动装配是如何运作的

93
00:04:20,900 --> 00:04:22,700
了解什么是依赖注入

94
00:04:22,700 --> 00:04:24,700
也知道一些简单的

95
00:04:24,700 --> 00:04:26,608
例如需要包含application.properties 

96
00:04:26,608 --> 00:04:29,256
以便应用在启动时可以初始化

97
00:04:29,700 --> 00:04:31,500
所以当你使用Spring Native

98
00:04:31,600 --> 00:04:35,400
你会得到一种类似GraalVM版本的静态分析

99
00:04:35,400 --> 00:04:38,400
但这个对Spring有所倾斜

100
00:04:38,796 --> 00:04:39,874
然后它的输出是

101
00:04:39,874 --> 00:04:41,843
一系列这些JSON配置文件

102
00:04:41,855 --> 00:04:44,351
输入到后面的原生构建过程

103
00:04:45,918 --> 00:04:46,683
尽管现在...

104
00:04:47,335 --> 00:04:50,959
Spring的关键知识 高层次概念已集成到Spring Native里

105
00:04:50,959 --> 00:04:52,677
它需要是要给可扩展的系统

106
00:04:53,605 --> 00:04:56,990
如果你想一下现存的各种自动配置的需求

107
00:04:57,065 --> 00:04:59,811
那会是加载某些特定的资源

108
00:04:59,811 --> 00:05:01,015
访问不同的代理

109
00:05:01,015 --> 00:05:02,206
或是反射类型

110
00:05:02,896 --> 00:05:06,231
而且 总会有新的自动装配会被编写出来...

111
00:05:06,231 --> 00:05:08,025
那需要一些新的机制

112
00:05:08,351 --> 00:05:11,272
所以我们需要一个可扩展的系统去支持那种变化

113
00:05:11,786 --> 00:05:14,633
那么我们有的是一个提示系统(hinting system)

114
00:05:15,210 --> 00:05:17,304
那么我就给你看看那是什么样的

115
00:05:18,758 --> 00:05:19,811
在你看到一个提示之前

116
00:05:19,862 --> 00:05:21,780
这就是要给反射配置文件的样子

117
00:05:21,855 --> 00:05:24,915
这是一个特定的文件 你可能自己维护的

118
00:05:24,927 --> 00:05:27,272
原生镜像构建过程可能用到这些输入

119
00:05:27,912 --> 00:05:30,921
这个表示我想在镜像中通过反射访问

120
00:05:30,921 --> 00:05:32,576
CommandLineRunner和SpringApplication

121
00:05:32,621 --> 00:05:32,626
CommandLineRunner和SpringApplication

122
00:05:33,128 --> 00:05:33,630
对于这个

123
00:05:33,630 --> 00:05:35,648
我想看到所有的构造器和所有方法

124
00:05:35,699 --> 00:05:37,742
而对于这个我想看一个特定的方法

125
00:05:37,918 --> 00:05:38,858
当在做反射的时候

126
00:05:39,561 --> 00:05:40,952
如果你可以做得明确

127
00:05:40,952 --> 00:05:43,523
那明确性对于保持镜像体积小是重要的

128
00:05:43,523 --> 00:05:44,639
保持低内存消耗

129
00:05:45,592 --> 00:05:47,184
这个文件有些问题

130
00:05:47,648 --> 00:05:50,056
我不想类型名称以字符串形式编码

131
00:05:50,821 --> 00:05:52,012
这样缺少类型安全

132
00:05:52,426 --> 00:05:54,006
如果一些东西改了名称

133
00:05:54,006 --> 00:05:55,423
突然间这文件就会过时

134
00:05:55,423 --> 00:05:56,275
然后你不知道这个问题

135
00:05:56,764 --> 00:05:59,197
而且你会随时间流逝在上下文迷失

136
00:05:59,987 --> 00:06:02,056
例如 这个文件只有20行的长度

137
00:06:02,332 --> 00:06:04,112
我见过1万行长度的文件

138
00:06:04,626 --> 00:06:06,921
如果我6个月后再看那文件

139
00:06:07,360 --> 00:06:10,206
我会疑惑这个特定的类型是什么用的

140
00:06:10,532 --> 00:06:12,062
为什么我们需要反射访问它

141
00:06:12,376 --> 00:06:14,094
这里没什么告知你原因

142
00:06:14,771 --> 00:06:16,269
所以我们尝试用在Spring Native中的

143
00:06:16,269 --> 00:06:19,360
提示系统应对这两个问题

144
00:06:20,351 --> 00:06:21,805
所以这是一个你可以在Spring Native编写

145
00:06:21,805 --> 00:06:23,460
的原生提示(native hints)

146
00:06:23,699 --> 00:06:25,705
这在概念上非常简单

147
00:06:25,780 --> 00:06:27,134
基本上是有个触发器

148
00:06:27,222 --> 00:06:28,614
会被触发

149
00:06:29,115 --> 00:06:30,896
然后这里有一系列东西

150
00:06:31,047 --> 00:06:33,642
会被放到镜像中

151
00:06:33,642 --> 00:06:36,551
通过将这些放到JSON配置文件

152
00:06:37,040 --> 00:06:39,799
那么这里有个 TaskExecutionAutoConfiguration的触发器

153
00:06:39,799 --> 00:06:44,601
如果Spring Native发现它在这个应用中是激活状态

154
00:06:45,191 --> 00:06:47,937
那么这部分就会发生是配置文件中

155
00:06:48,514 --> 00:06:52,125
那么这些基本上就是你在刚才的JSON文件看到的数据

156
00:06:52,438 --> 00:06:54,608
它意思是我想通过反射访问一个类型

157
00:06:55,021 --> 00:06:56,313
然后这些是我想看到的

158
00:06:56,313 --> 00:06:58,482
类对象和构造器

159
00:07:00,426 --> 00:07:01,542
那么如果这个提示触发

160
00:07:01,542 --> 00:07:04,263
这些信息就会被保存到JSON配置文件

161
00:07:04,263 --> 00:07:05,517
然后被输入到构建系统

162
00:07:07,197 --> 00:07:08,664
我们得到了想要的类型安全

163
00:07:08,702 --> 00:07:10,144
同时也有我们想要的上下文

164
00:07:10,144 --> 00:07:11,791
如果6个月后我奇怪为什么

165
00:07:11,791 --> 00:07:13,931
ThreadPoolTaskExecutor在我的镜像

166
00:07:14,420 --> 00:07:15,738
我可以在这里找到 噢

167
00:07:15,738 --> 00:07:18,219
 原来是因为TaskExecutionAutoConfiguration

168
00:07:19,021 --> 00:07:20,376
那么 是时候审查一下了

169
00:07:20,376 --> 00:07:21,479
然后去看一下

170
00:07:21,479 --> 00:07:24,526
看是否还重要 是否还有必要有这个条目

171
00:07:25,291 --> 00:07:27,059
你可以用提示(hints)做很多事情

172
00:07:27,611 --> 00:07:29,855
任何可以在JSON文件做的都可以放在这里

173
00:07:30,570 --> 00:07:32,313
代理、资源、类型

174
00:07:32,664 --> 00:07:35,021
选项以及初始化设置等各种东西

175
00:07:35,974 --> 00:07:37,843
现在我不会继续深入

176
00:07:37,843 --> 00:07:40,050
我建议你去看看文档

177
00:07:41,354 --> 00:07:42,658
当我们开始Spring Native项目时

178
00:07:43,072 --> 00:07:45,993
那是插入到GraalVM的原生镜像构建处理流程

179
00:07:46,758 --> 00:07:48,351
然后两者共同作用构建镜像

180
00:07:48,589 --> 00:07:50,432
随着我们开始做优化

181
00:07:50,432 --> 00:07:52,677
因为我们想产出更好的镜像

182
00:07:53,040 --> 00:07:54,871
我们意识到其中一些优化

183
00:07:54,871 --> 00:07:57,416
不仅对于构建原生镜像的用户

184
00:07:57,416 --> 00:08:00,426
甚至对普通的 乐意在JVM运行应用的用户也有好处 

185
00:08:01,379 --> 00:08:03,661
所以我们所做的是

186
00:08:03,661 --> 00:08:05,304
在这个0.9发布版作了转变

187
00:08:05,366 --> 00:08:09,341
我们将Spring Native从一个原生镜像构建器

188
00:08:09,667 --> 00:08:11,699
推前到更前期的处理流程

189
00:08:12,300 --> 00:08:13,956
然后现在我们在0.9版本有

190
00:08:13,956 --> 00:08:14,959
如果你看看Spring Native

191
00:08:14,984 --> 00:08:16,050
就是AOT

192
00:08:16,087 --> 00:08:17,178
提前编译框架

193
00:08:17,567 --> 00:08:20,902
在常规工程构建结尾运行

194
00:08:21,040 --> 00:08:24,952
这里我指的是常规构建中将Java编译成字节码

195
00:08:26,094 --> 00:08:29,241
有个AOT框架会在那个时机切入并做一些事情

196
00:08:29,805 --> 00:08:31,573
然后那可能会调用Spring Native

197
00:08:31,611 --> 00:08:34,068
去生成原生镜像配置文件

198
00:08:34,520 --> 00:08:36,626
也可能生成一些Java代码

199
00:08:36,852 --> 00:08:37,542
并编译

200
00:08:37,768 --> 00:08:40,388
以优化稍后的Spring启动

201
00:08:41,103 --> 00:08:42,658
那么接下来我就交给Brian了

202
00:08:42,658 --> 00:08:45,279
他会更深入一点讲解这个AOT框架

203
00:08:45,692 --> 00:08:45,981
感谢

204
00:08:48,413 --> 00:08:49,529
嘿 我是 Brian

205
00:08:49,805 --> 00:08:52,626
我通常是在Spring框架和Spring Boot项目干活

206
00:08:52,677 --> 00:08:54,645
尤其是跟Web相关的特性

207
00:08:55,084 --> 00:08:57,742
最近我被邀请到Spring Native项目

208
00:08:57,742 --> 00:08:59,586
因为我们需要处理某些问题

209
00:09:00,363 --> 00:09:02,670
你或许了解 Spring框架是非常灵活的

210
00:09:02,934 --> 00:09:04,253
而Spring Boot擅长将

211
00:09:04,253 --> 00:09:08,075
开发者见解转化为运行时配置

212
00:09:09,216 --> 00:09:10,144
在原生的世界里

213
00:09:10,181 --> 00:09:13,015
要提供那样的灵活性会带来成本上升

214
00:09:13,667 --> 00:09:14,971
原生二进制文件的体积

215
00:09:14,971 --> 00:09:15,736
内存消耗

216
00:09:15,736 --> 00:09:16,965
还有编译时间

217
00:09:17,667 --> 00:09:19,899
我们的软件开发者想要解决那问题

218
00:09:19,899 --> 00:09:21,943
以一种赋能社区的方式

219
00:09:22,319 --> 00:09:25,579
但同时在维护着的角度看也是可持续发展的

220
00:09:26,332 --> 00:09:28,275
这就是为什么从0.9版本开始

221
00:09:28,438 --> 00:09:30,808
Spring Native发行包含了提起编译模块

222
00:09:31,448 --> 00:09:33,655
这AOT模块负责两件事：

223
00:09:34,495 --> 00:09:37,855
一件事是 它会查看应用程序的见解(opinions)

224
00:09:38,106 --> 00:09:40,539
例如类路径和配置文件

225
00:09:41,078 --> 00:09:43,122
第二件事是 使用那些信息

226
00:09:43,272 --> 00:09:46,231
它会生成额外的Java代码和静态资源

227
00:09:47,623 --> 00:09:48,940
有了这些额外文件

228
00:09:49,015 --> 00:09:52,100
我们不仅可以通过预计算配置等更多内容

229
00:09:52,100 --> 00:09:53,993
使得Spring启动过程更流畅

230
00:09:54,457 --> 00:09:58,131
还可以使得GraalVM原生编译过程更加高效

231
00:09:59,485 --> 00:10:01,191
当然这一切都为你做好了

232
00:10:01,191 --> 00:10:03,824
得益于我们的新Maven和Gradle构建插件

233
00:10:04,551 --> 00:10:06,131
如果你将它们添加到你的应用

234
00:10:06,131 --> 00:10:09,467
它们会为main源码配置AOT处理

235
00:10:09,467 --> 00:10:10,871
而且test源码也会处理

236
00:10:11,623 --> 00:10:13,141
这个过程完全是透明的

237
00:10:13,141 --> 00:10:15,347
而且你可以查看生成的代码

238
00:10:15,347 --> 00:10:16,238
可以进行调试

239
00:10:17,028 --> 00:10:18,595
你可以查看参考文档

240
00:10:18,595 --> 00:10:19,460
如果你想了解更多的话

241
00:10:20,489 --> 00:10:22,558
我们正在实验这种新方式

242
00:10:22,645 --> 00:10:24,865
并且目前对结果满意

243
00:10:25,429 --> 00:10:26,921
如果你有机会尝试一下

244
00:10:26,921 --> 00:10:27,874
告诉我们你怎么想吧

245
00:10:31,034 --> 00:10:31,410
嗨

246
00:10:32,163 --> 00:10:33,266
我叫Jens Schauder

247
00:10:33,655 --> 00:10:34,896
我是Spring Native团队一份子

248
00:10:35,949 --> 00:10:38,708
当然如果你想编写认真的应用

249
00:10:39,047 --> 00:10:40,702
你需要一些持久化层

250
00:10:41,391 --> 00:10:43,811
可能是 Java Persistence API(JPA)

251
00:10:44,313 --> 00:10:46,457
或许封装在Spring Data JPA之中

252
00:10:46,796 --> 00:10:49,667
你可以在Spring Native中用它

253
00:10:50,695 --> 00:10:53,291
只是除了Spring Native的依赖

254
00:10:53,630 --> 00:10:56,213
再加上Spring Data JPA依赖

255
00:10:56,288 --> 00:10:57,981
在start.spring.io

256
00:10:58,633 --> 00:10:59,611
然后就算准备好了

257
00:11:00,978 --> 00:11:01,956
只是一个小警告

258
00:11:02,934 --> 00:11:04,313
我们尽量让它可用

259
00:11:04,777 --> 00:11:07,159
但还没有尝试让它体积变小

260
00:11:07,536 --> 00:11:11,799
所以原生镜像的体积会比我们想象中的大

261
00:11:12,714 --> 00:11:15,699
但 这会在未来的版本中改进

262
00:11:16,238 --> 00:11:17,667
如果你不喜欢JPA

263
00:11:18,457 --> 00:11:20,225
也有其它的模块可以用

264
00:11:20,915 --> 00:11:21,755
MongoDB

265
00:11:22,068 --> 00:11:24,438
命令式的和反应式(响应式)的都有

266
00:11:24,852 --> 00:11:25,680
R2DBC

267
00:11:26,307 --> 00:11:27,210
Spring Data JDBC

268
00:11:27,247 --> 00:11:28,388
Neo4j

269
00:11:28,589 --> 00:11:29,442
ElasticSearch

270
00:11:30,031 --> 00:11:31,097
我好像忘了Redis

271
00:11:31,962 --> 00:11:32,764
这些都有的

272
00:11:33,241 --> 00:11:34,357
都准备好给你尝试了

273
00:11:34,846 --> 00:11:36,250
所以试一下吧

274
00:11:38,294 --> 00:11:39,197
嗨 我是 Ria

275
00:11:39,347 --> 00:11:41,304
我是Spring Security团队的维护者

276
00:11:42,106 --> 00:11:44,626
我们想确保你安全地构建你所有的应用

277
00:11:44,802 --> 00:11:46,482
所以当然我们在Spring Native

278
00:11:46,482 --> 00:11:47,573
添加了Spring Security支持

279
00:11:48,250 --> 00:11:50,219
让我们讲一下我们目前工作

280
00:11:51,009 --> 00:11:53,253
你可以使用表单登录去保护你的应用

281
00:11:53,404 --> 00:11:55,410
或者是HTTP basic验证

282
00:11:56,175 --> 00:11:57,830
我们也支持OAuth 2

283
00:11:58,194 --> 00:11:59,912
client和resource server都支持

284
00:12:00,777 --> 00:12:02,570
如果你想用Kotlin编写你的应用

285
00:12:02,746 --> 00:12:03,899
可以的 这也支持

286
00:12:04,326 --> 00:12:05,592
然后如果你使用RSocket

287
00:12:05,680 --> 00:12:07,034
这个我们也支持

288
00:12:07,937 --> 00:12:09,366
如果你有一直关注我们

289
00:12:09,416 --> 00:12:10,194
你可能记得

290
00:12:10,269 --> 00:12:13,128
你以前要添加 --enable-all-security-services

291
00:12:13,442 --> 00:12:14,620
到原生镜像命令

292
00:12:14,896 --> 00:12:16,238
以便让Spring Security可以用

293
00:12:17,040 --> 00:12:18,708
你不需要再手动添加那个了

294
00:12:18,858 --> 00:12:21,253
因为我们有提示(hints) 它会为你自动添加

295
00:12:21,579 --> 00:12:23,410
当检测到Spring Security时

296
00:12:24,175 --> 00:12:25,128
如果你像开始

297
00:12:25,329 --> 00:12:27,310
去Spring Native项目的GitHub页面

298
00:12:27,636 --> 00:12:29,015
并看看安全相关的例子

299
00:12:32,250 --> 00:12:32,589
嗨

300
00:12:33,040 --> 00:12:34,658
我名字是 David Syer

301
00:12:35,084 --> 00:12:38,131
我为VMware工作

302
00:12:38,620 --> 00:12:40,137
我在Spring团队 然后...

303
00:12:40,576 --> 00:12:43,661
我一直有帮助Spring Native团队...

304
00:12:44,000 --> 00:12:45,692
加快开发速度

305
00:12:45,692 --> 00:12:48,476
并与Spring Cloud的东西集成

306
00:12:48,877 --> 00:12:51,222
那么今天我想给你演示一下这些

307
00:12:52,576 --> 00:12:53,529
那么这就是那项目

308
00:12:53,755 --> 00:12:54,633
在GitHub

309
00:12:55,084 --> 00:12:58,294
然后这里有一堆例子

310
00:12:58,357 --> 00:13:01,542
你可以看到 其中一些名称里有带cloud的

311
00:13:02,394 --> 00:13:03,611
有些还是半成品(WIP, work in progress)

312
00:13:04,075 --> 00:13:05,216
我们首先做的其中一件事是

313
00:13:05,216 --> 00:13:07,661
是这些serverless应用场景

314
00:13:08,075 --> 00:13:10,282
那个是使用Spring Cloud Function的

315
00:13:10,670 --> 00:13:12,952
这里我们有三个例子

316
00:13:12,952 --> 00:13:14,833
一个是用于Lambda

317
00:13:14,833 --> 00:13:16,012
AWS 的 Lambda λ

318
00:13:16,401 --> 00:13:18,018
部署以及定制化的运行时

319
00:13:18,771 --> 00:13:22,056
还有两个 基本上是funcion相关的

320
00:13:22,608 --> 00:13:24,639
例子 名称是cloud-function-netty

321
00:13:24,639 --> 00:13:27,109
其中一个是基于注解的 而另一个是...

322
00:13:28,213 --> 00:13:31,122
函数式的配置而不是使用注解

323
00:13:32,188 --> 00:13:33,617
那么 实际我想做的是

324
00:13:33,617 --> 00:13:36,815
给你在IDE演示简单的netty版本

325
00:13:38,244 --> 00:13:38,971
好了在这边

326
00:13:39,059 --> 00:13:40,025
然后这个...

327
00:13:40,664 --> 00:13:41,554
这个应用

328
00:13:41,554 --> 00:13:43,097
只是Spring Boot应用

329
00:13:44,288 --> 00:13:46,081
我可以在这里运行它

330
00:13:46,470 --> 00:13:47,510
就在IDE里

331
00:13:47,510 --> 00:13:48,827
我不需要...它会...

332
00:13:49,115 --> 00:13:50,119
打开一个端口

333
00:13:50,119 --> 00:13:52,601
一个在8080的HTTP端口 我可以...

334
00:13:53,329 --> 00:13:54,470
在本地跟它交互

335
00:13:55,009 --> 00:13:56,200
它的运作方式是...

336
00:13:56,815 --> 00:13:58,670
它有单一的组件

337
00:13:58,670 --> 00:14:00,037
它的类型是Function

338
00:14:00,213 --> 00:14:02,407
这是一个从String映射到String的函数

339
00:14:02,583 --> 00:14:05,391
我也可以做从POJO映射到POJO 或者...

340
00:14:06,031 --> 00:14:07,611
业务对象映射到业务对象

341
00:14:08,062 --> 00:14:08,689
那么...

342
00:14:08,789 --> 00:14:09,592
这里我们想要做的是

343
00:14:09,592 --> 00:14:11,021
我们想要构建...

344
00:14:11,836 --> 00:14:12,902
一个原生镜像

345
00:14:12,902 --> 00:14:14,282
然后最容易的做法是

346
00:14:15,059 --> 00:14:15,460
是...

347
00:14:19,172 --> 00:14:20,815
使用Spring Boot插件

348
00:14:24,112 --> 00:14:26,332
那么我们给它几分钟去完成

349
00:14:30,658 --> 00:14:32,075
那么快完成了

350
00:14:32,802 --> 00:14:33,078
它...

351
00:14:34,369 --> 00:14:37,667
回过头来告诉我它构建了一个容器

352
00:14:38,219 --> 00:14:39,222
cloud-function-netty

353
00:14:40,112 --> 00:14:42,821
让我们看看能不能用Docker运行它

354
00:14:43,134 --> 00:14:44,100
这是我的Docker命令

355
00:14:44,100 --> 00:14:45,905
我会用8080端口运行它

356
00:14:46,583 --> 00:14:48,852
然后 这是Docker镜像名称

357
00:14:50,570 --> 00:14:51,235
它运行了

358
00:14:51,360 --> 00:14:53,918
启动时间大概45毫秒

359
00:14:54,658 --> 00:14:57,329
然后我们可以就用curl与它交互

360
00:14:57,717 --> 00:14:59,811
那么这就是curl命令

361
00:15:00,739 --> 00:15:03,510
我用curl发进 Dave

362
00:15:03,811 --> 00:15:06,144
然后 Content-Type是 text/plain

363
00:15:06,194 --> 00:15:08,137
然后末尾打印新行

364
00:15:10,056 --> 00:15:11,247
OK 它给我发回了

365
00:15:11,435 --> 00:15:12,112
hi Dave!

366
00:15:12,476 --> 00:15:13,579
这就是我让它做的

367
00:15:13,617 --> 00:15:14,269
这很好

368
00:15:14,557 --> 00:15:16,714
那么为了让它运行起来我需要做什么

369
00:15:16,714 --> 00:15:19,159
我需要将一个常规的Spring Boot

370
00:15:19,536 --> 00:15:21,216
Spring Cloud Function应用

371
00:15:21,692 --> 00:15:22,884
然后我添加了

372
00:15:23,548 --> 00:15:24,351
一个依赖

373
00:15:24,952 --> 00:15:25,692
Spring Native

374
00:15:26,796 --> 00:15:28,075
还有一个插件

375
00:15:28,789 --> 00:15:30,633
spring-aot-maven-plugin

376
00:15:31,347 --> 00:15:32,789
然后其它的我做了

377
00:15:32,789 --> 00:15:35,824
配置那个Spring Boot Maven插件去构建原生镜像

378
00:15:35,937 --> 00:15:37,880
所以这里是有个文件你可以设置它那样做

379
00:15:38,006 --> 00:15:39,987
你可以查看父级POM找到它

380
00:15:40,238 --> 00:15:42,796
那么我可以拿现在得到的那个镜像

381
00:15:42,796 --> 00:15:44,902
我可以部署到 例如...

382
00:15:45,492 --> 00:15:46,470
Google Cloud Run

383
00:15:46,470 --> 00:15:47,862
或者如果我想使用...

384
00:15:48,112 --> 00:15:49,304
AWS的 Lambda

385
00:15:49,366 --> 00:15:50,557
要将它变成Lambda适用的

386
00:15:50,557 --> 00:15:53,429
我需要添加这个spring-cloud-function-aws适配器

387
00:15:53,429 --> 00:15:56,300
到类路径但我不需要改源码

388
00:15:57,291 --> 00:15:59,849
那么这就是我要给你演示的全部内容

389
00:16:00,025 --> 00:16:02,445
那里有一些特性你可以探索的

390
00:16:02,620 --> 00:16:04,213
有 Spring Cloud Config Client

391
00:16:04,313 --> 00:16:05,780
Spring Cloud Config Server

392
00:16:06,420 --> 00:16:08,652
那将会有更多的特性会添加进来

393
00:16:08,652 --> 00:16:13,554
随着我们做跟多的Spring Native库发布

394
00:16:14,244 --> 00:16:15,523
那么 非常感谢您

395
00:16:18,733 --> 00:16:20,915
嘿 那么让我们谈谈路线图

396
00:16:21,216 --> 00:16:24,413
额 那个 0.9 Beta 发布版

397
00:16:24,489 --> 00:16:28,150
已经可以让我们设置这新的AOT基础设施了

398
00:16:28,150 --> 00:16:30,532
这解锁了很多可能性

399
00:16:31,561 --> 00:16:36,426
我们准备发布0.9.1 bugfix 发布版

400
00:16:37,291 --> 00:16:42,106
而且我们已经开始开发0.10版了

401
00:16:42,119 --> 00:16:44,664
那么 0.10 也是一个较大的发布版

402
00:16:45,115 --> 00:16:48,351
因为它是关于编译转换@Configutation

403
00:16:49,028 --> 00:16:53,880
到基于lambda或方法引用结构的函数式配置

404
00:16:53,880 --> 00:16:56,489
然后这对于我们的支持是很重要的

405
00:16:56,489 --> 00:16:59,485
因为这类编程式的结构

406
00:17:00,150 --> 00:17:03,598
是能被GraalVM原生镜像编译器自动识别的

407
00:17:04,037 --> 00:17:07,912
然后这样会允许我们移除大量的反射入口

408
00:17:07,999 --> 00:17:09,905
那些我们当前用于配置的

409
00:17:10,570 --> 00:17:14,658
能达到更好的兼容性和更小的镜像的目的

410
00:17:16,815 --> 00:17:18,344
额 感谢关注我们

411
00:17:18,746 --> 00:17:23,184
请随意到start.spring.io测试Spring Native支持

412
00:17:23,523 --> 00:17:25,141
你可以报告bug修复

413
00:17:25,642 --> 00:17:28,639
在Spring Native的GitHub仓库

414
00:17:28,927 --> 00:17:30,746
同时也请随意贡献对

415
00:17:30,846 --> 00:17:33,216
你喜欢的Spring Boot starter的支持

416
00:17:33,216 --> 00:17:37,266
或者是其它依赖 如果你想这样做的话 感谢！

